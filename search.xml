<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>代码随想录训练营01</title>
      <link href="/2022/09/21/dai-ma-sui-xiang-lu-xun-lian-ying-01/"/>
      <url>/2022/09/21/dai-ma-sui-xiang-lu-xun-lian-ying-01/</url>
      
        <content type="html"><![CDATA[<h1 id="代码随想录训练营Day01"><a href="#代码随想录训练营Day01" class="headerlink" title="代码随想录训练营Day01"></a>代码随想录训练营Day01</h1><h2 id="Leetcode刷题"><a href="#Leetcode刷题" class="headerlink" title="Leetcode刷题"></a>Leetcode刷题</h2><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h3><blockquote><p>题目中描述数组有序且无重复元素，二者为使用二分查找的前提！</p></blockquote><p><code>二分查找要注意边界条件的判断！搞清楚区间的定义，二分查找边界的判断是根据区间的定义来操作的，二分法中区间的定义一般有两种，一种是左闭右闭[left, right]，一种是左闭右开[left, right)。</code></p><p>思路一：定义target在一个左闭右开的区间<code>[left, right)</code></p><blockquote><ol><li><code>left == right</code>在区间<code>[left, right)</code>内无意义，故循环条件为 <code>&lt;</code>；</li><li><code>若nums[middle] &lt; target，则更新左区间，由于定义的区间为左闭右开，所以left = middle + 1</code>;</li><li><code>若nums[middle] &gt; target，则更新右区间，由于定义的区间为左闭右开，所以right = middle</code>;</li><li><code>若在整个区间中未找到target，则返回-1</code>;</li></ol></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {public:    int search(vector&lt;int&gt;&amp; nums, int target) {                int left = 0;        int right = nums.size();                while (left &lt; right)  // 1.        {            // 防止溢出            int middle = left + ((right - left) / 2);                        if (nums[middle] &lt; target)  // 2.            {                left = middle + 1;            }            else if (nums[middle] &gt; target) // 3.            {                right = middle;            }            else  // left == right            {                return middle;            }        }                return -1;  // 4.    }    };<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路二：定义target在一个左闭右闭的区间<code>[left, right]</code></p><blockquote><ol><li><p><code>left == right</code>在区间<code>[left, right)</code>内有意义，故循环条件为<code>&lt;=</code>；</p></li><li><p><code>若nums[middle] &lt; target，则更新左区间，由于定义的区间为左闭右闭，所以right= middle - 1</code>；</p></li><li><p><code>若nums[middle] &gt; target，则更新右区间，由于定义的区间为左闭右闭，所以 left = middle + 1</code>;</p></li><li><p><code>若在整个区间中未找到target，则返回-1</code>;</p></li></ol></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {public:    int search(vector&lt;int&gt;&amp; nums, int target) {                int left = 0;        int right = nums.size() - 1;  //[left, right]，所以要-1                while (left &lt;= right)  // 1.        {                        // 防止溢出            int middle = left + ((right - left) &gt;&gt; 1);                        if (nums[middle] &lt; target)  // 2.            {                left = middle + 1;            }            else if (nums[middle] &gt; target)  // 3.            {                right = middle - 1;            }            else  // left == right            {                return middle;             }        }                return -1;  // 4.    }    };<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h3><blockquote><p>题目中描述<code>原地</code>移除元素，需要注意的是，数组中的元素无法真正移除，因为数组中的元素在内存地址上是连续的，不能单独删除数组中的某个元素，所以只能靠后面的元素覆盖前面的元素来实现元素的移除。</p></blockquote><p>思路：双指针法：通过一个快指针和一个慢指针在一个for循环内完成两个for循环的工作。</p><blockquote><ol><li>定义两个指针<code>slowIdx, fastIdx</code>分别对数组进行遍历；</li><li><code>fastIdx</code>在for循环中<code>一直向前移动</code>，如果<code>fastIdx指向的数组元素与目标val相等，slowIdx保持当前位置不变，fastIdx继续向后移动，直到遍历完整个数组</code>，注意<code>将fastIdx指向的最后一个元素更新到slowIdx中时，slowIdx要继续向前移动一个位置，而slowIdx最终指向的数组的位置（大小）即为更新后的新数组的元素个数</code>；</li><li><code>fastIdx</code>在for循环中<code>一直向前移动</code>，只有在<code>满足fastIdx指向的数组元素与目标val不相等的条件下，slowIdx才更新数组的值并向前移动</code>；</li></ol></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) {        int slowIdx = 0;                // fastIdx一直向后移动        for (inr fastIdx = 0; fastIdx &lt; nums.size(); fastIdx++)        {            if (val != nums[fastIdx])            {                // slowIdx只有在fastIdx满足条件的情况下才进行更新和移动                nums[slowIdx++] = nums[fastIdx];            }        }                // slowIdx即为新数组中包含的元素个数        return slowIdx;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>声明：此博客只作为学习记录，不做他用！！！参考链接：<a href="https://programmercarl.com/">https://programmercarl.com/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
