<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>代码随想录刷题训练营01</title>
      <link href="/2022/09/22/dai-ma-sui-xiang-lu-shua-ti-xun-lian-ying-01/"/>
      <url>/2022/09/22/dai-ma-sui-xiang-lu-shua-ti-xun-lian-ying-01/</url>
      
        <content type="html"><![CDATA[<h1>代码随想录刷题训练营Day01</h1><h2 id="Leetcode刷题">Leetcode刷题</h2><h3 id="704-二分查找">704. 二分查找</h3><blockquote><p>题目中描述数组有序且无重复元素，二者为使用二分查找的前提！</p></blockquote><p><code>二分查找要注意边界条件的判断！搞清楚区间的定义，二分查找边界的判断是根据区间的定义来操作的，二分法中区间的定义一般有两种，一种是左闭右闭[left, right]，一种是左闭右开[left, right)。</code></p><p>思路一：定义target在一个左闭右开的区间<code>[left, right)</code></p><blockquote><ol><li><code>left == right</code>在区间<code>[left, right)</code>内无意义，故循环条件为 <code>&lt;</code>；</li><li><code>若nums[middle] &lt; target，则更新左区间，由于定义的区间为左闭右开，所以left = middle + 1</code>;</li><li><code>若nums[middle] &gt; target，则更新右区间，由于定义的区间为左闭右开，所以right = middle</code>;</li><li><code>若在整个区间中未找到target，则返回-1</code>;</li></ol></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {public:    int search(vector&lt;int&gt;&amp; nums, int target) {                int left = 0;        int right = nums.size();                while (left &lt; right)  // 1.        {            // 防止溢出            int middle = left + ((right - left) / 2);                        if (nums[middle] &lt; target)  // 2.            {                left = middle + 1;            }            else if (nums[middle] &gt; target) // 3.            {                right = middle;            }            else  // left == right            {                return middle;            }        }                // 4.        return -1;    }    };<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路二：定义target在一个左闭右闭的区间<code>[left, right]</code></p><blockquote><ol><li><p><code>left == right</code>在区间<code>[left, right)</code>内有意义，故循环条件为<code>&lt;=</code>；</p></li><li><p><code>若nums[middle] &lt; target，则更新左区间，由于定义的区间为左闭右闭，所以right= middle - 1</code>；</p></li><li><p><code>若nums[middle] &gt; target，则更新右区间，由于定义的区间为左闭右闭，所以 left = middle + 1</code>;</p></li><li><p><code>若在整个区间中未找到target，则返回-1</code>;</p></li></ol></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {public:    int search(vector&lt;int&gt;&amp; nums, int target) {                int left = 0;        int right = nums.size() - 1;  //[left, right]，所以要-1                while (left &lt;= right)  // 1.        {                        // 防止溢出            int middle = left + ((right - left) &gt;&gt; 1);                        if (nums[middle] &lt; target)  // 2.            {                left = middle + 1;            }            else if (nums[middle] &gt; target)  // 3.            {                right = middle - 1;            }            else  // left == right            {                return middle;             }        }                return -1;  // 4.    }    };<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="27-移除元素">27. 移除元素</h3><blockquote><p>题目中描述<code>原地</code>移除元素，需要注意的是，数组中的元素无法真正移除，因为数组中的元素在内存地址上是连续的，不能单独删除数组中的某个元素，所以只能靠后面的元素覆盖前面的元素来实现元素的移除。</p></blockquote><p>思路：双指针法：通过一个快指针和一个慢指针在一个for循环内完成两个for循环的工作。</p><blockquote><ol><li>定义两个指针<code>slowIdx, fastIdx</code>分别对数组进行遍历；</li><li><code>fastIdx</code>在for循环中<code>一直向前移动</code>，如果<code>fastIdx指向的数组元素与目标val相等，slowIdx保持当前位置不变，fastIdx继续向后移动，直到遍历完整个数组</code>，注意<code>将fastIdx指向的最后一个元素更新到slowIdx中时，slowIdx要继续向前移动一个位置，而slowIdx最终指向的数组的位置（大小）即为更新后的新数组的元素个数</code>；</li><li><code>fastIdx</code>在for循环中<code>一直向前移动</code>，只有在<code>满足fastIdx指向的数组元素与目标val不相等的条件下，slowIdx才更新数组的值并向前移动</code>；</li></ol></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) {        int slowIdx = 0;                // fastIdx一直向后移动        for (inr fastIdx = 0; fastIdx &lt; nums.size(); fastIdx++)        {            if (val != nums[fastIdx])            {                // slowIdx只有在fastIdx满足条件的情况下才进行更新和移动                nums[slowIdx++] = nums[fastIdx];            }        }                // slowIdx即为新数组中包含的元素个数        return slowIdx;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>声明：此博客只作为学习记录，不做他用！！！参考链接：<a href="https://programmercarl.com/">https://programmercarl.com/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录刷题训练营02</title>
      <link href="/2022/09/22/dai-ma-sui-xiang-lu-shua-ti-xun-lian-ying-02/"/>
      <url>/2022/09/22/dai-ma-sui-xiang-lu-shua-ti-xun-lian-ying-02/</url>
      
        <content type="html"><![CDATA[<h1>代码随想录刷题训练营02</h1><h2 id="Leetcode刷题">Leetcode刷题</h2><h3 id="977-有序数组的平方">977. 有序数组的平方</h3><blockquote><p>题目中描述非递减顺序排序的数组，平方后依旧非递减有序。</p></blockquote><p>思路一：暴力破解，将数组所有元素平方后快排即可</p><blockquote><ol><li>将数组所有元素平方；</li><li>快速排序；</li></ol></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {public:        void quick_sort(vector&lt;int&gt;&amp; nums, int l, int r)  // 2.    {        if (l &gt;= r) return;                int i = l - 1, j = r + 1, x = nums[l + r &gt;&gt; 1];                while (i &lt; j)        {            do i++; while (nums[i] &lt; x);            do j--; while (nums[j] &gt; x);            if (i &lt; j) swap(nums[i], nums[j]);        }                quick_sort(nums, l, j), quick_sort(nums, j+ 1, r);    }        vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) {                for (int i = 0; i &lt; nums.size(); i++)  // 1.        {            nums[i] *= nums[i];        }                // 快排注意右边界的值！！！        quick_sort(nums, 0, nums.size() - 1);                return nums;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思路二：双指针法，数组本身有序，负数平方之后可能成为最大的数，那么平方后的最大值在数组的两端，不是左边就是右边。</p><blockquote><ol><li><p>定义两个指针，<code>i</code>指向起始位置，<code>j</code>指向终止位置;</p></li><li><p>定义一个新数组res，与<code>原数组（nums）</code>大小相同，让<code>k指向res数组的终止位置</code>；</p></li></ol><p><code>如果 nums[i] * nums[i] &lt; nums[j] * nums[j]，则res[k--] = nums[j] * nums[j];</code></p><p><code>如果nums[i] * nums[i] &gt;= nums[j] * nums[j]，则res[k--] = nums[i] * nums[i];</code></p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) {                vector&lt;int&gt; res(nums.size(), 0);          int k = nums.size() - 1;        // 因为要处理两个元素，所以i &lt;= j        for (int i = 0, j = nums.size() - 1; i &lt;= j;)        {            if (nums[i] * nums[i] &lt; nums[j] * nums[j])            {                res[k--] = nums[j] * nums[j];                j--;            }            else            {                res[k--] = nums[i] * nums[i];                i++;            }        }        return res;    }    };<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="209-长度最小的子数组">209. 长度最小的子数组</h3><blockquote><p>题目中描述在一个数组中找到<code>最小长度</code>的<code>连续子数组</code>，找到返回数组长度，未找到返回0。</p></blockquote><p>思路：滑动窗口，不断调节子数组的起始位置和终止位置，从而满足条件。滑动窗口也是双指针的一种！<code>关键在于如何移动窗口的起始位置！！！</code></p><blockquote><p>滑动窗口要确定以下三点：</p><ul><li>窗口内的元素是什么？<ul><li>保持窗口内数值总和大于或等于s的长度最小的连续子数组；</li></ul></li><li>如何移动窗口的起始位置？<ul><li>如果当前窗口的值大于s，则窗口向前移动（即窗口缩小）；</li></ul></li><li>如何移动窗口的终止位置？<ul><li>窗口的终止位置就是for循环遍历数组的指针；</li></ul></li></ul></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {public:    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) {        int res = INT32_MAX;        int slowIdx = 0;  // 滑动窗口的起始位置        int sum = 0;  // 滑动窗口的数值之和        int subLength = 0;  // 滑动窗口的长度                for (int fastIdx = 0; fastIdx &lt; nums.size(); fastIdx++)        {            sum += nums[fastIdx];            // 该处使用while，每次更新i（起始位置）并不断比较子数组是否符合条件            while (sum &gt;= target)            {                subLength = fastIdx - slowIdx + 1;  // 获取子数组的长度                res = res &lt; subLength ? res : subLength;                // 不断变换子数组的起始位置（滑动窗口的精髓）                sum -= nums[slowIdx++];            }        }        // 如果res没有被赋值，则返回0，说明没有符合条件的子数组        return res == INT32_MAX ? 0 : res;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="59-螺旋矩阵">59. 螺旋矩阵</h3><blockquote><p>题目中描述顺时针遍历n×n的正方形螺旋矩阵</p></blockquote><p>思路：类比矩阵！</p><blockquote><ol><li>以中心位置为原点，设置4个方向（上、下、左、右）的偏移量；</li><li>定义当前点（原点）的坐标和方向</li><li>遍历整个矩阵，并填充元素；</li><li>求出从当前坐标点沿某方向走到的下一个坐标点；</li><li>判断是否走到了重复的坐标处或撞墙：<ol><li>如果撞墙，则改变方向（方向 + 1） % 4；</li><li>更新当前方向的坐标点；</li></ol></li><li>如果不满足5，则更新坐标点（此时的a和b一定没有出界或撞墙）；</li></ol></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution {public:    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) {        vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0));        int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};  // 1.        int x = 0, y = 0, d = 1;  // 2.        for (int i = 1; i &lt;= n * n; i++)          {            res[x][y] = i;  // 3.            int a = x + dx[d], b = y + dy[d];  // 4.            if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= n || res[a][b]) // 5.            {                d = (d + 1) % 4;  // 5.1                a = x + dx[d], b = y + dy[d];  // 5.2            }            x = a, y = b;  // 6.        }        return res;        /*        // 打印测试        for (int i = 0; i &lt; n; i++)        {            for (int j = 0; j &lt; n; j++)                printf("%d", res[i][j]);            cout &lt;&lt; endl;        }        */    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>声明：此博客只作为学习记录，不做他用！！！参考链接：<a href="https://programmercarl.com/">https://programmercarl.com/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
